use std::collections::HashMap;
use std::fs;
use std::ops::Deref;
use std::sync::LazyLock;

use clatter::bytearray::ByteArray;
use clatter::handshakepattern::*;
use clatter::traits::{Cipher, Dh, Hash};
use clatter::{Handshaker, KeyPair, NqHandshake};
use serde::Deserialize;

const PATTERNS: LazyLock<HashMap<String, HandshakePattern>> = LazyLock::new(|| {
    let handshakes = [
        noise_n(),
        noise_k(),
        noise_x(),
        noise_ik(),
        noise_in(),
        noise_ix(),
        noise_kk(),
        noise_kn(),
        noise_kx(),
        noise_nk(),
        noise_nn(),
        noise_nx(),
        noise_xk(),
        noise_xn(),
        noise_xx(),
        noise_n_psk0(),
        noise_k_psk0(),
        noise_x_psk1(),
        noise_ik_psk1(),
        noise_ik_psk2(),
        noise_in_psk1(),
        noise_in_psk2(),
        noise_ix_psk2(),
        noise_kk_psk0(),
        noise_kk_psk2(),
        noise_kn_psk0(),
        noise_kn_psk2(),
        noise_kx_psk2(),
        noise_nk_psk0(),
        noise_nk_psk2(),
        noise_nn_psk0(),
        noise_nn_psk2(),
        noise_nx_psk2(),
        noise_xk_psk3(),
        noise_xn_psk3(),
        noise_xx_psk3(),
    ];

    let mut patterns = HashMap::new();

    for hs in handshakes {
        patterns.insert(hs.get_name().to_string(), hs);
    }

    patterns
});

#[derive(Debug)]
struct Hex(Vec<u8>);

impl Deref for Hex {
    type Target = Vec<u8>;

    fn deref(&self) -> &Vec<u8> {
        &self.0
    }
}

impl AsRef<[u8]> for Hex {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

impl<'de> Deserialize<'de> for Hex {
    fn deserialize<D>(d: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let v = hex::serde::deserialize(d)?;
        Ok(Self(v))
    }
}

#[derive(Debug, Deserialize)]
struct Vectors {
    vectors: Vec<Vector>,
}

#[derive(Debug, Deserialize)]
struct Vector {
    protocol_name: String,
    init_prologue: Option<Hex>,
    init_ephemeral: Hex,
    init_static: Option<Hex>,
    init_remote_static: Option<Hex>,
    init_psks: Option<Vec<Hex>>,
    resp_prologue: Option<Hex>,
    resp_ephemeral: Option<Hex>,
    resp_static: Option<Hex>,
    resp_remote_static: Option<Hex>,
    resp_psks: Option<Vec<Hex>>,
    handshake_hash: Option<Hex>,
    messages: Vec<Message>,
}

#[derive(Debug, Deserialize)]
struct Message {
    payload: Hex,
    ciphertext: Hex,
}

impl Vector {
    fn parse_protocol_name(&self) -> (String, String, String, String) {
        let mut parts = self.protocol_name.split("_").skip(1);
        (
            parts.next().unwrap().into(),
            parts.next().unwrap().into(),
            parts.next().unwrap().into(),
            parts.next().unwrap().into(),
        )
    }
}

// Generated by build.rs
include!(concat!(env!("OUT_DIR"), "/crypto_mapping.rs"));

fn verify_vector_with<DH, CIPHER, HASH>(v: &Vector) -> bool
where
    DH: Dh,
    CIPHER: Cipher,
    HASH: Hash,
{
    let (pattern, _, _, _) = v.parse_protocol_name();
    let pattern = match PATTERNS.get(&pattern) {
        Some(p) => p.clone(),
        None => {
            return false;
        }
    };

    let alice_prologue: &[u8] = v.init_prologue.as_ref().map_or(&[], |p| p.as_ref());
    let bob_prologue: &[u8] = v.resp_prologue.as_ref().map_or(&[], |p| p.as_ref());

    let alice_ephemeral = DH::PrivateKey::from_slice(&v.init_ephemeral);
    let alice_ephemeral = Some(KeyPair {
        public: DH::pubkey(&alice_ephemeral),
        secret: alice_ephemeral,
    });

    let bob_ephemeral = match v.resp_ephemeral.as_ref() {
        None => None,
        Some(s) => {
            let s = DH::PrivateKey::from_slice(&s);
            Some(KeyPair {
                secret: s.clone(),
                public: DH::pubkey(&s),
            })
        }
    };

    let alice_static = match v.init_static.as_ref() {
        None => None,
        Some(s) => {
            let s = DH::PrivateKey::from_slice(&s);
            Some(KeyPair {
                secret: s.clone(),
                public: DH::pubkey(&s),
            })
        }
    };

    let bob_static = match v.resp_static.as_ref() {
        None => None,
        Some(s) => {
            let s = DH::PrivateKey::from_slice(&s);
            Some(KeyPair {
                secret: s.clone(),
                public: DH::pubkey(&s),
            })
        }
    };

    let alice_remote_static = v
        .init_remote_static
        .as_ref()
        .map_or(None, |s| Some(DH::PubKey::from_slice(&s)));
    let bob_remote_static = v
        .resp_remote_static
        .as_ref()
        .map_or(None, |s| Some(DH::PubKey::from_slice(&s)));

    let alice_psks: &[Hex] = v.init_psks.as_ref().map_or(&[], |p| &p);
    let bob_psks: &[Hex] = v.resp_psks.as_ref().map_or(&[], |p| &p);

    let mut alice_rng = rand::thread_rng();
    let mut alice = Some(
        NqHandshake::<DH, CIPHER, HASH, _>::new(
            pattern.clone(),
            alice_prologue,
            true,
            alice_static,
            alice_ephemeral,
            alice_remote_static,
            None,
            &mut alice_rng,
        )
        .unwrap(),
    );

    let mut bob_rng = rand::thread_rng();
    let mut bob = Some(
        NqHandshake::<DH, CIPHER, HASH, _>::new(
            pattern.clone(),
            bob_prologue,
            false,
            bob_static,
            bob_ephemeral,
            bob_remote_static,
            None,
            &mut bob_rng,
        )
        .unwrap(),
    );

    for psk in alice_psks {
        alice.as_mut().unwrap().push_psk(psk);
    }

    for psk in bob_psks {
        bob.as_mut().unwrap().push_psk(psk);
    }

    assert_eq!(*alice.as_ref().unwrap().get_name(), *v.protocol_name);

    let mut initiators_turn = true;
    let mut handshake_done = false;

    let mut send_buf = [0; 4096];
    let mut receive_buf = [0; 4096];

    let mut initiator_transport = None;
    let mut responder_transport = None;

    for m in &v.messages {
        let payload = &m.payload;
        let ciphertext = &m.ciphertext;

        if !handshake_done {
            let (sender, receiver) = if initiators_turn {
                (alice.as_mut().unwrap(), bob.as_mut().unwrap())
            } else {
                (bob.as_mut().unwrap(), alice.as_mut().unwrap())
            };

            assert!(sender.is_write_turn());
            assert!(!receiver.is_write_turn());
            let overhead = sender.get_next_message_overhead().unwrap();
            assert_eq!(payload.len() + overhead, ciphertext.len());

            // Write and verify ciphertext
            let n = sender.write_message(&payload, &mut send_buf).unwrap();
            assert_eq!(&send_buf[..n], ciphertext.as_ref());

            // Receive
            let n = receiver
                .read_message(&send_buf[..n], &mut receive_buf)
                .unwrap();
            assert_eq!(&receive_buf[..n], payload.as_ref());

            if sender.is_finished() {
                assert!(receiver.is_finished());

                initiator_transport = Some(alice.take().unwrap().finalize().unwrap());
                responder_transport = Some(bob.take().unwrap().finalize().unwrap());

                let h_i = initiator_transport.as_ref().unwrap().get_handshake_hash();
                let h_r = responder_transport.as_ref().unwrap().get_handshake_hash();

                assert_eq!(h_i, h_r);

                if let Some(h) = v.handshake_hash.as_ref() {
                    assert_eq!(h_i.as_slice(), h.as_ref());
                }

                handshake_done = true;
            }
        } else {
            if initiators_turn {
                let n = initiator_transport
                    .as_mut()
                    .unwrap()
                    .send(&payload, &mut send_buf)
                    .unwrap();
                assert_eq!(&send_buf[..n], ciphertext.as_ref());
                let n = responder_transport
                    .as_mut()
                    .unwrap()
                    .receive(&send_buf[..n], &mut receive_buf)
                    .unwrap();
                assert_eq!(&receive_buf[..n], payload.as_ref());
            } else {
                let n = responder_transport
                    .as_mut()
                    .unwrap()
                    .send(&payload, &mut send_buf)
                    .unwrap();
                assert_eq!(&send_buf[..n], ciphertext.as_ref());
                let n = initiator_transport
                    .as_mut()
                    .unwrap()
                    .receive(&send_buf[..n], &mut receive_buf)
                    .unwrap();
                assert_eq!(&receive_buf[..n], payload.as_ref());
            }
        }

        if !pattern.is_one_way() {
            initiators_turn = !initiators_turn;
        }
    }

    true
}

#[test]
fn cacophony_vectors() {
    let cacophony = fs::read_to_string("cacophony.txt").unwrap();
    let vectors: Vectors = serde_json::from_str(&cacophony).unwrap();

    let mut skipped = 0;
    let mut completed = 0;

    for v in &vectors.vectors {
        if verify_vector(v) {
            completed += 1;
        } else {
            skipped += 1;
        }
    }

    println!("Cacophony vectors: {completed} completed, {skipped} skipped");
}

#[test]
fn snow_vectors() {
    let snow = fs::read_to_string("snow.txt").unwrap();
    let vectors: Vectors = serde_json::from_str(&snow).unwrap();

    let mut skipped = 0;
    let mut completed = 0;

    for v in &vectors.vectors {
        if verify_vector(v) {
            completed += 1;
        } else {
            skipped += 1;
        }
    }

    println!("Cacophony vectors: {completed} completed, {skipped} skipped");
}
